// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LuWeiKeVideo.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "LuWeiKeVideo.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - LuWeiKeVideoRoot

@implementation LuWeiKeVideoRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - LuWeiKeVideoRoot_FileDescriptor

static GPBFileDescriptor *LuWeiKeVideoRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.luole.luweike.proto"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum SMPConst

GPBEnumDescriptor *SMPConst_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "PageMaxNumber\000CurveScaleBase\000CurveThickS"
        "tdInPageWidth\000CurveThickStdInPageHeight\000";
    static const int32_t values[] = {
        SMPConst_PageMaxNumber,
        SMPConst_CurveScaleBase,
        SMPConst_CurveThickStdInPageWidth,
        SMPConst_CurveThickStdInPageHeight,
    };
    static const char *extraTextFormatInfo = "\004\000\r\000\001\016\000\002\030\000\003\031\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SMPConst)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SMPConst_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SMPConst_IsValidValue(int32_t value__) {
  switch (value__) {
    case SMPConst_PageMaxNumber:
    case SMPConst_CurveScaleBase:
    case SMPConst_CurveThickStdInPageWidth:
    case SMPConst_CurveThickStdInPageHeight:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SMPConstCurve

GPBEnumDescriptor *SMPConstCurve_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ScaleMin\000ScaleMax\000";
    static const int32_t values[] = {
        SMPConstCurve_ScaleMin,
        SMPConstCurve_ScaleMax,
    };
    static const char *extraTextFormatInfo = "\002\000\010\000\001\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SMPConstCurve)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SMPConstCurve_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SMPConstCurve_IsValidValue(int32_t value__) {
  switch (value__) {
    case SMPConstCurve_ScaleMin:
    case SMPConstCurve_ScaleMax:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SMPGraphics

@implementation SMPGraphics

@dynamic hasType, type;
@dynamic hasThickness, thickness;
@dynamic hasColor, color;
@dynamic touchCurvesArray, touchCurvesArray_Count;

typedef struct SMPGraphics__storage_ {
  uint32_t _has_storage_[1];
  SMPGraphics_TYPE type;
  uint32_t thickness;
  uint32_t color;
  NSMutableArray *touchCurvesArray;
} SMPGraphics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SMPGraphics_TYPE_EnumDescriptor,
        .number = SMPGraphics_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPGraphics__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "thickness",
        .dataTypeSpecific.className = NULL,
        .number = SMPGraphics_FieldNumber_Thickness,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPGraphics__storage_, thickness),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "color",
        .dataTypeSpecific.className = NULL,
        .number = SMPGraphics_FieldNumber_Color,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPGraphics__storage_, color),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "touchCurvesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPGraphics_TouchCurves),
        .number = SMPGraphics_FieldNumber_TouchCurvesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPGraphics__storage_, touchCurvesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPGraphics class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPGraphics__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\024\000touchCurves\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SMPGraphics_TYPE

GPBEnumDescriptor *SMPGraphics_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TtouchCurves\000TtouchLines\000";
    static const int32_t values[] = {
        SMPGraphics_TYPE_TtouchCurves,
        SMPGraphics_TYPE_TtouchLines,
    };
    static const char *extraTextFormatInfo = "\002\000b\n\000\001b\t\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SMPGraphics_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SMPGraphics_TYPE_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SMPGraphics_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case SMPGraphics_TYPE_TtouchCurves:
    case SMPGraphics_TYPE_TtouchLines:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SMPGraphics_TouchCurves

@implementation SMPGraphics_TouchCurves

@dynamic hasTime, time;
@dynamic hasX, x;
@dynamic hasY, y;
@dynamic hasLineScale, lineScale;

typedef struct SMPGraphics_TouchCurves__storage_ {
  uint32_t _has_storage_[1];
  int32_t time;
  int32_t x;
  int32_t y;
  float lineScale;
} SMPGraphics_TouchCurves__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "time",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SMPGraphics_TouchCurves_FieldNumber_Time,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(SMPGraphics_TouchCurves__storage_, time),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "x",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SMPGraphics_TouchCurves_FieldNumber_X,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(SMPGraphics_TouchCurves__storage_, x),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "y",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SMPGraphics_TouchCurves_FieldNumber_Y,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(SMPGraphics_TouchCurves__storage_, y),
        .core.flags = GPBFieldRequired,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueFloat = 1,
        .core.name = "lineScale",
        .core.dataTypeSpecific.className = NULL,
        .core.number = SMPGraphics_TouchCurves_FieldNumber_LineScale,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(SMPGraphics_TouchCurves__storage_, lineScale),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldTextFormatNameCustom),
        .core.dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPGraphics_TouchCurves class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(SMPGraphics_TouchCurves__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SMPGraphics)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPModel

@implementation SMPModel

@dynamic graphicsArray, graphicsArray_Count;

typedef struct SMPModel__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *graphicsArray;
} SMPModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "graphicsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPGraphics),
        .number = SMPModel_FieldNumber_GraphicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPModel__storage_, graphicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPModel class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPModel_Status

@implementation SMPModel_Status

@dynamic hasX, x;
@dynamic hasY, y;

typedef struct SMPModel_Status__storage_ {
  uint32_t _has_storage_[1];
  int32_t x;
  int32_t y;
} SMPModel_Status__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = SMPModel_Status_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPModel_Status__storage_, x),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = SMPModel_Status_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPModel_Status__storage_, y),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPModel_Status class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPModel_Status__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SMPModel)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPImage

@implementation SMPImage

@dynamic hasImageId, imageId;

typedef struct SMPImage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t imageId;
} SMPImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imageId",
        .dataTypeSpecific.className = NULL,
        .number = SMPImage_FieldNumber_ImageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPImage__storage_, imageId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPImage class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPImage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SMPImage_ORIENTATION

GPBEnumDescriptor *SMPImage_ORIENTATION_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Up\000Right\000Down\000Left\000";
    static const int32_t values[] = {
        SMPImage_ORIENTATION_Up,
        SMPImage_ORIENTATION_Right,
        SMPImage_ORIENTATION_Down,
        SMPImage_ORIENTATION_Left,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SMPImage_ORIENTATION)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SMPImage_ORIENTATION_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SMPImage_ORIENTATION_IsValidValue(int32_t value__) {
  switch (value__) {
    case SMPImage_ORIENTATION_Up:
    case SMPImage_ORIENTATION_Right:
    case SMPImage_ORIENTATION_Down:
    case SMPImage_ORIENTATION_Left:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SMPImage_Status

@implementation SMPImage_Status

@dynamic hasOrientation, orientation;
@dynamic hasX, x;
@dynamic hasY, y;
@dynamic hasScale, scale;

typedef struct SMPImage_Status__storage_ {
  uint32_t _has_storage_[1];
  SMPImage_ORIENTATION orientation;
  int32_t x;
  int32_t y;
  float scale;
} SMPImage_Status__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orientation",
        .dataTypeSpecific.enumDescFunc = SMPImage_ORIENTATION_EnumDescriptor,
        .number = SMPImage_Status_FieldNumber_Orientation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPImage_Status__storage_, orientation),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = SMPImage_Status_FieldNumber_X,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPImage_Status__storage_, x),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = SMPImage_Status_FieldNumber_Y,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPImage_Status__storage_, y),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "scale",
        .dataTypeSpecific.className = NULL,
        .number = SMPImage_Status_FieldNumber_Scale,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SMPImage_Status__storage_, scale),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPImage_Status class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPImage_Status__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SMPImage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPAniModel

@implementation SMPAniModel

@dynamic hasType, type;
@dynamic hasTime, time;
@dynamic hasIndex, index;
@dynamic hasStatus, status;

typedef struct SMPAniModel__storage_ {
  uint32_t _has_storage_[1];
  SMPAniModel_TYPE type;
  int32_t time;
  int32_t index;
  SMPModel_Status *status;
} SMPAniModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SMPAniModel_TYPE_EnumDescriptor,
        .number = SMPAniModel_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPAniModel__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniModel_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPAniModel__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniModel_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPAniModel__storage_, index),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPModel_Status),
        .number = SMPAniModel_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SMPAniModel__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPAniModel class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPAniModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SMPAniModel_TYPE

GPBEnumDescriptor *SMPAniModel_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Show\000Hide\000";
    static const int32_t values[] = {
        SMPAniModel_TYPE_Show,
        SMPAniModel_TYPE_Hide,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SMPAniModel_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SMPAniModel_TYPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SMPAniModel_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case SMPAniModel_TYPE_Show:
    case SMPAniModel_TYPE_Hide:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SMPAniImage

@implementation SMPAniImage

@dynamic hasType, type;
@dynamic hasTime, time;
@dynamic hasIndex, index;
@dynamic hasOrderStep, orderStep;
@dynamic hasStatus, status;

typedef struct SMPAniImage__storage_ {
  uint32_t _has_storage_[1];
  SMPAniImage_TYPE type;
  int32_t time;
  int32_t index;
  int32_t orderStep;
  SMPImage_Status *status;
} SMPAniImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SMPAniImage_TYPE_EnumDescriptor,
        .number = SMPAniImage_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPAniImage__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniImage_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPAniImage__storage_, time),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniImage_FieldNumber_Index,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPAniImage__storage_, index),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "orderStep",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniImage_FieldNumber_OrderStep,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SMPAniImage__storage_, orderStep),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPImage_Status),
        .number = SMPAniImage_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SMPAniImage__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPAniImage class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPAniImage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\n\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum SMPAniImage_TYPE

GPBEnumDescriptor *SMPAniImage_TYPE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Show\000Hide\000Order\000Status\000";
    static const int32_t values[] = {
        SMPAniImage_TYPE_Show,
        SMPAniImage_TYPE_Hide,
        SMPAniImage_TYPE_Order,
        SMPAniImage_TYPE_Status,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SMPAniImage_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SMPAniImage_TYPE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SMPAniImage_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case SMPAniImage_TYPE_Show:
    case SMPAniImage_TYPE_Hide:
    case SMPAniImage_TYPE_Order:
    case SMPAniImage_TYPE_Status:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SMPPage

@implementation SMPPage

@dynamic hasWidth, width;
@dynamic hasHeight, height;
@dynamic imagesArray, imagesArray_Count;
@dynamic imageAnisArray, imageAnisArray_Count;
@dynamic modelsArray, modelsArray_Count;
@dynamic modelAnisArray, modelAnisArray_Count;

typedef struct SMPPage__storage_ {
  uint32_t _has_storage_[1];
  uint32_t width;
  uint32_t height;
  NSMutableArray *imagesArray;
  NSMutableArray *imageAnisArray;
  NSMutableArray *modelsArray;
  NSMutableArray *modelAnisArray;
} SMPPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = SMPPage_FieldNumber_Width,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPPage__storage_, width),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = SMPPage_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPPage__storage_, height),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPImage),
        .number = SMPPage_FieldNumber_ImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPPage__storage_, imagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imageAnisArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPAniImage),
        .number = SMPPage_FieldNumber_ImageAnisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPPage__storage_, imageAnisArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPModel),
        .number = SMPPage_FieldNumber_ModelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPPage__storage_, modelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "modelAnisArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPAniModel),
        .number = SMPPage_FieldNumber_ModelAnisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPPage__storage_, modelAnisArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPPage class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPPage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\025\000imageAnis\000\027\000modelAnis\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPAniPage

@implementation SMPAniPage

@dynamic hasIndex, index;
@dynamic hasTimeStart, timeStart;
@dynamic hasTimeEnd, timeEnd;

typedef struct SMPAniPage__storage_ {
  uint32_t _has_storage_[1];
  int32_t index;
  int32_t timeStart;
  int32_t timeEnd;
} SMPAniPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniPage_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPAniPage__storage_, index),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStart",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniPage_FieldNumber_TimeStart,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPAniPage__storage_, timeStart),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeEnd",
        .dataTypeSpecific.className = NULL,
        .number = SMPAniPage_FieldNumber_TimeEnd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPAniPage__storage_, timeEnd),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPAniPage class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPAniPage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\t\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPPackageData

@implementation SMPPackageData

@dynamic hasPageStartIndex, pageStartIndex;
@dynamic hasImageIdmax, imageIdmax;
@dynamic hasTotalTime, totalTime;
@dynamic pagesArray, pagesArray_Count;
@dynamic pageAnisArray, pageAnisArray_Count;

typedef struct SMPPackageData__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageStartIndex;
  uint32_t imageIdmax;
  int32_t totalTime;
  NSMutableArray *pagesArray;
  NSMutableArray *pageAnisArray;
} SMPPackageData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageStartIndex",
        .dataTypeSpecific.className = NULL,
        .number = SMPPackageData_FieldNumber_PageStartIndex,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPPackageData__storage_, pageStartIndex),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageIdmax",
        .dataTypeSpecific.className = NULL,
        .number = SMPPackageData_FieldNumber_ImageIdmax,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPPackageData__storage_, imageIdmax),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "totalTime",
        .dataTypeSpecific.className = NULL,
        .number = SMPPackageData_FieldNumber_TotalTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPPackageData__storage_, totalTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPPage),
        .number = SMPPackageData_FieldNumber_PagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPPackageData__storage_, pagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pageAnisArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SMPAniPage),
        .number = SMPPackageData_FieldNumber_PageAnisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SMPPackageData__storage_, pageAnisArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPPackageData class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPPackageData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\016\000\002\006b\002\000\003\t\000\025\000pageAnis\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SMPPackageExData

@implementation SMPPackageExData

@dynamic hasUuid, uuid;
@dynamic hasCreateTime, createTime;
@dynamic hasLength, length;

typedef struct SMPPackageExData__storage_ {
  uint32_t _has_storage_[1];
  int32_t length;
  NSString *uuid;
  int64_t createTime;
} SMPPackageExData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = SMPPackageExData_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SMPPackageExData__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = SMPPackageExData_FieldNumber_CreateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SMPPackageExData__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "length",
        .dataTypeSpecific.className = NULL,
        .number = SMPPackageExData_FieldNumber_Length,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SMPPackageExData__storage_, length),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SMPPackageExData class]
                                     rootClass:[LuWeiKeVideoRoot class]
                                          file:LuWeiKeVideoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SMPPackageExData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
